---
title: '[Java] 6. 패키지'
date: 2021-04-27 22:04:38
category: java
thumbnail: { thumbnailSrc }
draft: true
---


## 패키지 키워드

- 클래스가 .class 파일로 존재하는 것처럼 패키지도 디렉토리로 존재하며 디렉토리와 이름이 일치해야한다.

- 패키지는 서로 관련된 클래스와 인터페이스를 묶음

- 리눅스의 폴더 계층 구조를 트리형으로 나타내는 것과 같이 계층 구조를 나타내며 패키지는 서브 패키지를 가질 수 있다.

- 클래스가 속한 패키지명을 포함한 이름(FQCN)이 있다.(String 클래스의 FQCN은 java.lang.String) 

- rt.jar는 java의 기본 API의 클래스들을 압축한 파일 (jdk 설치 경로에 \jre\lib에 존재한다)

- 패키지는 클래스 파일에 맨 첫줄에서 단 한번만 선언한다.

- 자바는 모든 패키지의 가장 상위 디렉토리에서 실행해야한다는 규칙/약속이 있다.

- 하나의 패키지에는 단 하나의 public class를 허용한다.

  

### 패키지 이름 명명 규칙

- 각 요소를 점(.)으로 구분하여 계층적으로 짓는다. 
- 요소는 모두 소문자 알파벳으로 구성되며 드물게 숫자가 들어가기도 한다. 
- 계층을 구성할 때는 조직 바깥에서도 사용될 패키지라면 도메인의 역순으로 구성한다. 
- 패키지의 이름에서 각 요소는 8자 이하의 짧은 단어를 사용한다. utilities -> util 처럼 의미가 통하도록 약어를 사용하는 것도 추천한다. 
- 예약어를 사용하면 안된다.

#### 예시

```
com.google.code.gson

org.projectlombok.lombok

org.apache.logging.log4j.logger
```



#### 기본 built-in 패키지

자바는 개발자들이 사용하도록 여러 많은 패키지를 기본적으로 제공하는데, 예를 들면 `java.lang`과 `java.util`이 존재한다. 하지만 이것들은 import가 자동적으로 이루어지기 때문에 import를하여 사용할 필요가 없다.

예를 들면 `System` 클래스와 `String` 클래스가 있다.

```java
package com.example
  
public class Main{
  public static void main(String[] args){
    System.out.println("Hello world!");
  }
}
```



## Import 키워드

`import 패키지명.클래스명`을 사용하여 import한다.

다른 패키지명에 있는 클래스를 찾지 못할때 사용한다. 패키지 아래 다수의 클래스를 한번에 import 하는 경우 import 패키지명.*을 사용할 수 있다. 

import를 하지 않고 다른 패키지의 클래스를 사용할 수 있지만 패키지명 전체를 적어서 사용하기 때문에 거의 대부분 import를 이용하며 클래스명을 찾지 못하는 경우 IDE(intelij)가 Alt+Enter를 통하면 자동적으로 import를 불러와 준다. 

Import static으로 가져오는 경우 클래스명을 생략하고 바로 메서드를 사용 할 수있기 때문에 용이하며 주로 예를 들어, `assertThat`과 같은 테스트 코드 작성시 `Assertions.assertThat`과 같이 중복이 있는 코드를 가독성 좋게 표현할 수있다.

같은 패키지(같은 디렉토리)에 속하는 경우는 import를 하지 않아도 클래스명을 바로 불러올 수있다(같은 계층에 있기 때문). 



## 접근 제어자

접근 제어자: 멤버 또는 클래스에 사용되어, 외부로부터의 접근을 제한 할 수 있도록 한다.

- 외부로부터 불필요한 접근을 막고, 내부에서만 사용되는 데이터를 감춘다.
- `private`: 같은 클래스 내에서만 접근이 가능하다.
- `protected`: 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
- `default`: 같은 패키지 내에서만 접근이 가능하다.
- `public`: 모든 곳에서 접근이 가능하다.
- 

|  제어자(사용 가능 대상)   | 같은 클래스 | 같은 패키지 | 자손 클래스 | 모두 |
| :-----------------------: | :---------: | :---------: | :---------: | :--: |
|  **public(클래스,멤버)**  |      o      |      o      |      o      |  o   |
|    **protected(멤버)**    |      o      |      o      |      o      |  x   |
| **default(클래스, 멤버)** |      o      |      o      |      x      |  x   |
|     **private(멤버)**     |      o      |      x      |      x      |  x   |

## 



## 클래스 패스

클래스를 찾기 위한 경로이다. 왜, 그리고 언제 클래스 패스가 필요할까?

JVM은 **프로그램을 실행하게 되면** 클래스파일을 찾아 **클래스를 로딩하는 때**, 그때 클래스를 찾기위해 **클래스패스**라는 것을 이용한다.

다시 말해 CLASSPATH의 경로를 확인하여 라이브러리 클래스들의 위치를 참조하게 된다. 하지만 J2JDK 버전 부터는 jdk 설치 경로의 \jre\lib\ext 폴더에 필요한 클래스 라이브러리들을 복사해 놓으면 사용가능하기 때문에 특별한 경우가 아니면 설정을 하지 않는다.

[JVM 작동 방식](https://gogojun.com/java/2021-04-01-[java]-1-jvm/) 을 보게 되면 우리는 자바 소스코드를 .class 바이트 코드로 컴파일하게 되는 데 클래스 파일들 자바 런타임시 불러오기 위해서는 이 파일들을 찾을 수 있어야 한다. 따라서 이 파일들을 찾기 위해 classpath로 지정된 경로를 탐색하여 파일 찾게 된다.

classpath는 두가지 방식을 통해 지정할 수 있다.  

1. CLASSPATH 환경변수 설정 및 사용
2. java runtime에 -classpath 플래그를 통해 넘겨주는 경우

### 환경 변수 설정을 통한 CLASSPATH 설정

환경 변수를 설정하는 것은 사실 시스템 환경마다 다르다. 하지만 나는 MacOS 환경이기 때문에 간단히 설정하는 방법을 소개하면

```bash
vim ~/.zshrc 
#파일을 들어가서
export CLASSPATH=.$JAVA_HOME/lib:추가하고싶은경로 
#입력 후 저장

```

클래스 패스라는 경로를 설정하는데 윈도우의 경우 여러 개의 경로를 구분짓는 구분자로 세미콜론을 사용하는데 반해서 리눅스 계열에서는 콜론을 사용하여 구분짓는 차이가 있다. 

또한 구분자를 통해 패스를 찾게되는 경우 첫번째 나오는 곳에서 먼저 클래스의 존재를 먼저 찾고 있다면 그것을 활용하기 때문에 어떤 것을 먼저 적느냐인 순서가 중요하다. 뒤에 나오는 옵션에서도 마찬가지로 구분자와 경로를 찾을 때 똑같은 방식으로 적용된다.

#### javac -classpath 옵션을 통한 사용

위는 시스템의 환경 변수를 설정하여 옵션을 주었다면, 자바에서 컴파일하기 위해 필요한 클래스 파일들을 가져오는 환경 변수를 입력하는 경우 다음과 같이 사용할 수있다. 마찬가지로 :를 이용하여 구분자를 지어주며, -cp로 요약하여 사용 가능하다.

`javac -cp .:$JAVA_HOME/lib:..`