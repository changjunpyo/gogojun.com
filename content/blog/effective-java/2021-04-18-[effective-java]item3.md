---
title: '[Effective-Java] Item3. private 생성자나 열거 타입으로 싱글턴임을 보증하라'
date: 2021-04-18 22:04:36
category: effective-java
thumbnail: { thumbnailSrc }
draft: false
---

## 싱글턴

단일체(Singleton) 패턴으로, 오직 ***한 개의 클래스 인스턴스*** 만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.

### 필요성

특정한 클래스의 경우는 정확히 하나의 인스턴스를 갖도록 하는 것이 좋다. 예를 들면 파일 시스템이라던지, 윈도우 관리자라 던지 하는 것들은 하나만 존재해야 한다.

 `DBCP(DataBase Connection Pool)`과 같이 공통된 객체를 여러개 생성해서 사용해야 하는 경우 단일체 패턴을 이용하게 된다면 다른 인스턴스들과 데이터를 공유하기 쉽다.

전역 변수를 통해서 이객체만 접근하도록 하는 방법을 사용한다면 여러개의 인스턴스를 만들 필요가 없다. 하지만 이것보다 더 좋은 방법은 클래스가 자신이 자기의 유일한 인스턴스로 접근하는 방법을 자체적으로 관리하도록 하는 것이다. 

이 클래스는 다른 인스턴스가 생성되지 않도록 하며(새로운 객체 생성 요청을 가로채서 원래 인스턴스를 주는 방식으로), 클래스 자신이 그 인스턴스에 대한 접근 방법을 제공한다.

### 사용 해야하는 경우

- 인스턴스가 **하나임을 보장**하고, 그것을 사용하는 방법을 하나로 만들어야 할 때.
- 유일한 인스턴스가 **서브 클래스로 확장**되어야 하며, 소스의 수정없이  확장된 서브클래스를 이용하고자 할 때 (static의 한계)


### 싱글턴 생성 방법


싱글턴을 만드는 방법은 2가지이다. 더 정확하게 말하면 인스턴스를 정적 타입으로 초기에 메모리에 올려서 싱글턴 방식으로 만드는 방법만 한정해서 보자(런타임에 인스턴스를 생성하는 방법은 추후에 소개하도록 하겠다)

두 방법 모두 생성자는 `private`로 하여 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 `public static` 멤버를 하나 마련해둔다.

첫 번째로 `public static` 멤버가 `final` 필드인 방식을 보자.

```java
public class Singleton{
  public static final Singleton INSTANCE = new Singleton();
  private Singleton() {...}
  ...
}
```

`private`의 생성자는 `public static final` 필드인 `Singleton.INSTANCE`를 초기화 하는 경우 한번만 호출 된다. 생성자가 `private` 하나뿐이므로 클라이언트는 생성을 할 수 없고 전체 시스템에서 인스턴스 하나임을 보장한다. 

예외로 권한이 있는 클라이언트가 리플렉션 API인 `AccessibleObject.setAccessible`을 사용해 `private` 생성자를 호출할 수 있다. 이러한 공격을 방어하려면 생성자를 수정하여 두번째 객체가 생성될 때 예외를 던지게 하는 방식을 사용 할 수있다.

두 번째 방법은 정적 팩터리 메서드를 `public static` 멤버로 제공한다.

```java
public class Singleton{
  private static final Singleton INSTANCE = new Singleton();
  private Singleton() {...}
  public static Singleton getInstance() { return INSTANCE; }
  ...
}
```

`Singleton.INSTANCE`는 항상 같은 객체를 반환함을 보장한다.(리플렉션을 통한 예외는 역시 존재) 

### public 필드 방식의 장점

`public` 필드 방식은 2가지의 장점이 존재하는데, 가장 큰 장점으로는 해당 클래스가 명확히 싱글턴임이 외부에 드러난다는 점이고 `final` 이기 때문에 다른 객체를 참조하지 못하며, 다른 장점으로는 간결함이다.

### 정적 팩터리 메서드 방식의 장점

#### 1. API를 바꾸지 않고 싱글턴이 아니게 되는 방식으로 변경이 가능

유일한 방식으로 제공하던 방식을 여러 접근하는 스레드별로 다르게 인스턴스를 제공하는 방식으로 변경이 가능하다.

#### 2. 정적 팩터리를 제너릭 싱글턴 팩터리로 만들 수 있음(Item 30 참조)

#### 3. 정적 팩터리의 메서드 참조자를 공급자로 사용이 가능(Item 43,44 참조) 



### 싱글턴 클래스의 직렬화 주의점

두가지의 방법 모두 직렬화하는 경우 단순히 `Serializable` 을 구현한다고 선언하기 보다 모든 인스턴스 필드를 일시적이라고 선언하고 `readResolve` 메서드를 제공해야 한다. 이렇게 하지 않는 경우 직렬화된 인스턴스가 역직렬화 되는 경우 새로운 인스턴스가 만들어져 싱글턴의 규칙이 깨지게 된다. 따라서 아래와 같은 `readResolve` 를 제공해야한다.

```java
// 싱글턴임을 보장해주는 readResolve 메서드
private Object readResolve(){
  // 진짜 싱글턴만을 반환하고 가짜 싱글턴은 가비지 컬렉터에 맡김
  return INSTANCE;
}
```

### Enum 타입 싱글턴

추가적인 싱글턴을 만드는 방법으로는 원소가 하나인 열거 타입을 선언하는 것이다.

```java
public enum Singleton {
  INSTANCE;
  
  ...// 추가 함수들
}
```

`public` 필드 방식과 비슷하지만, 더 간결해지고, 추가 노력 없이 직렬화가 가능하며, 여러 복잡한 직렬화 상황이나 리플렉션 공격에서 추가 인스턴스가 생기는 상황을 방어 해준다. **이런 측면에서 열거 타입을 통한 싱글턴을 만드는 방법은 매우 유용하다**

단점으로는 만드려는 싱글턴이 `Enum` 이 아닌 클래스를 상속하려 하는 상황에는 위 방법은 사용이 불가능하다.

#### 참조
*1. Effective java 3/e , by Joshua Bloch*