---
title: '[Effective-Java] Item1. 생성자 대신 정적 팩토리 메서드를 고려하자'
date: 2021-03-25 22:03:47
category: effective-java
thumbnail: { thumbnailSrc }
draft: false
---

### 정적 팩토리 메서드이란 ?

정적 팩토리 메서드라는 얘기를 처음 듣게 된다면 기존의 GoF의 [팩토리 메서드 패턴](https://johngrib.github.io/wiki/factory-method-pattern/)이 바로 떠오를 수 있다. 하지만 완전히 다른 개념으로 생각해야 한다. 팩토리라는 이름 측면에서 생성한다는 의미를 갖고 있는 정도라고만 같다고 할 수 있다. 


기본적인 클라이언트의 클래스 인스턴스를 생성하는 방식은 public constructor, 생성자이다.

하지만 추가적으로 클래스는 생성자와 별도로 아래와 같은 방식으로 정적 패터리 메서드를 제공 할 수 있다. 즉, 클래스의 인스턴스를 반환하는 단순한 정적 메서드를 말한다. 

```java
public static Boolean valueOf(boolean b) {
	return b ? Boolean.TRUE : Boolean.FALSE;
}
```

## **정적 팩토리 메서드의 장점**

### 1. 이름을 가질 수 있다.

ex) 소수인 biginterger를 반환하는 방법을 생각해보자.

**BigInterger(int, int , random)** 보다는 정적 팩토리 메서드인  **BigInteger.probablePrime** 가 더 명확하게 의미를 설명해 준다. 
따라서 가독성 측면에서 매우 효과적으로 사용 할 수 있게 된다.


### 2. 호출 시 마다 인스턴스를 새로 생성하지 않아도 된다.

불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 
즉, 여러 번의 반복적인 객체 생성이 이루어지는 것을 예방할 수 있다.

[플라이 웨이트 패턴(flyweight pattern)](https://lee1535.tistory.com/106)도 이와 비슷한 기법이라고 할 수 있다. 


### 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력을 가진다.

반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 '뛰어난 유연성'을 제공해 준다. 생성자의 경우는 리턴 타입이 존재하지 않기 때문에 하위 객체 반환해 줄 수 없지만 팩토리 메서드의 경우는 리턴을 하므로 하위 객체를 넘겨 주는 것이 가능하다.

따라서 API를 만들 때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다. 이것은 인터페이스를 정적 팩토리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술이기도 하다. 


### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환 하든 상관이 없다. 

가령 EnumSet 클래스는 public 생성자 없이 오직 정적 팩토리만 제공하는데, OpenJDK에서는 원소의 수에 따라 두 가지 하위 클래스 중 하나의 인스턴스를 반환한다. 원소가 64개 이하이면 원소들을 long 변수로 관리하는 RegularEnumSet, 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.
여러 정적 팩토리 메서드들은 다음과 같은 방식으로 생성된다.
```java
if (universe.length <= 64)
    return new RegularEnumSet<>(elementType, universe);
else
    return new JumboEnumSet<>(elementType, universe);
```
클라이언트는 이 두 클래스의 존재를 모른다. 두개로 나눠서 사용하는 것에 대한 이점이 사라진다면, 삭제하거나 바꿔주면 된다. 클라이언트는 팩토리가 건네주는 객체가 어떤 것인지 전혀 상관하지 않는다. 


### 5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

이러한 유연함은 서비스 제공자 프레임 워크를 만드는 근간이 된다. 대표적인 서비스 제공자 프레임 워크로는 JDBC가 있다. 서비스 제공자 프레임 워크에서 제공자는 서비스의 구현체다. 그리고 이 구현체들을 클라이언트에 제공하는 역할을 프레임 워크가 통제하여, 클라이언트를 구현체로부터 분리해준다라고 책에서 설명한다.
하지만 아직 이것이 어떤 의미인지 막 와 닿지는 않는다... 

## **단점**

### 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.

상속의 이점을 이용하고 싶다면 생성자를 이용하여서 생성되도록 하여야 한다.
이와 같은 제약은 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있다.


### 2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다.

생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩토리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다. 이 일을 언젠가 자바독이 알아서 처리해줬으면 좋겠으나, 그날이 오기까지는 API 문서를 잘 써놓고 메서드 이름도 널리 알려진 규약을 따라 짓는 식으로 문제를 완화해줘야 한다.

아래는 정적 팩토리 메서드에서 자주 사용되는 네이밍 컨벤션이다.

- **from**: 매개 변수를 하나 받아 해당 타입의 인스턴스를 반환
- **of**: 매개 변수를 여러개 받아 적합한 타입의 인스턴스 반환
- **valueOf**: from과 of의 더 자세한 버전
- **getInstance || instance**: 
  인스턴스의 생성. 매개변수로 명시한 인스턴스를 반환하지만 같음을 보장하지는 않음.
- **newInstance || create**: 
  새로운 인스턴스를 생성
- **get[Type]**: 
  getInstance와 비슷하지만 다른 클래스의 메서드를 정의할 때 사용. [Type]은 팩토리 메서드가 반환할 객체의 타입 
- **new[Type]**: newInstance의 다른 클래스의 메서드를 정의할 때 사용



## 결론

기본적으로 생성자와 정적 팩토리 메서드는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 중요하다. 

따라서 여기서 알아가야 하는 교훈은 무의식적으로 생성자를 통해 생성할 필요가 없다는 것, 상속이 요구되는 상황이 아니라면 정적 팩토리 메서드에 대한 고려가 필요하다는 점이다.


#### 참조
*1. Effective java 3/e , by Joshua Bloch*